---
title: 一种基于数据库的分布式锁设计
date: 2023-11-16 11:13:40
updated: 2023-11-16 11:13:40
excerpt: 本文介绍了一种基于数据库的分布式锁设计
categories: tech
math: true
tags: 
  - Golang
  - Database
---

> 在并发场景中，我们经常使用锁来解决数据的共享问题，但语言标准库中的锁往往只能应用于单机的场景，因为多实例部署的场景下，一个实例并不能获取到另一个实例内存中构建的锁。



## 分布式锁

简单来说，分布式锁一般会额外引入一个“中心化的节点”，让所有服务实例都向它请求锁，这样一来实例与实例之间就能通过这个中心化的节点来进行通信了。

上面提到的“中心化节点”的选型有很多种选择，在业内比较常见的有 Redis / ZooKeeper / 数据库等，本文介绍一种基于数据库的分布式锁设计，数据库本身的选型没有标准的答案，理论上来说只要支持唯一索引（Unique Index）的数据库都符合选型标准，例如常见的 MySQL 和 MongoDB。

为什么需要唯一索引？因为支持了唯一索引的数据库都具备以下的能力（不考虑硬件故障等意外情况）：

**<u>多个并发请求同时向数据库插入记录时，只有一个请求能够成功。</u>**并且失败的请求往往能够识别出失败的原因是来自竞争，例如 `Duplicate Key Error`。

可以看到，唯一索引的表现和语言标准库中的锁非常一致。



## 数据库表结构设计

```go
type PLock struct {
	ID       string // 数据库主键
	Key      string // 锁定的 key, 与 BizType 组成 uniq key
	Val      string // 锁的 value, 可以是业务相关的自定义数据
	BizType  string // 锁的类型, 与 Key 组成 uniq key
	ExpireAt int64  // 过期时间
}
```

这里为了阅读体验，我们将数据库表结构设计的尽量精简，实际情况中可以根据业务需要自行修改表结构。

上面可以看出，我们使用 `BizType` 和 `Key` 组成了一个唯一索引 `(BizType, Key)`，然后添加了两个额外的字段 `Val` / `ExpireAt` 来存储锁的额外信息。



## 加解锁流程设计

有了基本的表结构后，我们接下来需要考虑如何基于这张表来实现加解锁的流程，我们先做一个简单的抽象如下：
